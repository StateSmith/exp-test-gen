// Autogenerated with StateSmith 0.9.12-alpha.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class LightSm
{
    static EventId = 
    {
        ESCAPE : 0,
        EV1 : 1,
        EV2 : 2,
        EV3 : 3,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 4;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        ORDER_MENU : 1,
        BEVERAGE : 2,
        COFFEE : 3,
        TEA : 4,
        WATER : 5,
        FOOD : 6,
        JUNK : 7,
        POTATO : 8,
        SUSHI : 9,
        WAITING : 10,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 11;
    static { Object.freeze(this.StateIdCount); }
    
    static ORDER_MENU_HistoryId = 
    {
        BEVERAGE : 0, // default transition
        FOOD : 1,
        WATER : 2,
        COFFEE : 3,
        TEA : 4,
    }
    static { Object.freeze(this.ORDER_MENU_HistoryId); }
    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Used internally by state machine. Don't modify.
    #ancestorEventHandler;
    
    // Used internally by state machine. Don't modify.
    #currentEventHandlers = Array(LightSm.EventIdCount).fill(undefined);
    
    // Used internally by state machine. Don't modify.
    #currentStateExitHandler;
    
    // Variables. Can be used for inputs, outputs, user variables...
    vars = {
        ORDER_MENU_history: undefined,
        count: 0 // variable for state machine
        // your variable declartions here like: 
        // uint8_t count;
    };
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: TransitionTo(WAITING)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `WAITING`.
                this.#WAITING_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = LightSm.StateId.WAITING;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    dispatchEvent(eventId)
    {
        let behaviorFunc = this.#currentEventHandlers[eventId];
        
        while (behaviorFunc != null)
        {
            this.#ancestorEventHandler = null;
            behaviorFunc.call(this);
            behaviorFunc = this.#ancestorEventHandler;
        }
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredStateExitHandler)
    {
        while (this.#currentStateExitHandler != desiredStateExitHandler)
        {
            this.#currentStateExitHandler.call(this);
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#ROOT_exit;
    }
    
    #ROOT_exit()
    {
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ORDER_MENU
    ////////////////////////////////////////////////////////////////////////////////
    
    #ORDER_MENU_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#ORDER_MENU_exit;
        this.#currentEventHandlers[LightSm.EventId.EV3] = this.#ORDER_MENU_ev3;
        
        // ORDER_MENU behavior
        // uml: enter / { document.querySelector('g[data-id=ORDER_MENU]')?.classList.add('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=ORDER_MENU]')?.classList.add('active');`
            document.querySelector('g[data-id=ORDER_MENU]')?.classList.add('active');
        } // end of behavior for ORDER_MENU
        
        // ORDER_MENU behavior
        // uml: enter / { console.log("--> Entered ORDER_MENU."); }
        {
            // Step 1: execute action `console.log("--> Entered ORDER_MENU.");`
            console.log("--> Entered ORDER_MENU.");
        } // end of behavior for ORDER_MENU
    }
    
    #ORDER_MENU_exit()
    {
        // ORDER_MENU behavior
        // uml: exit / { console.log("<-- Exited ORDER_MENU."); }
        {
            // Step 1: execute action `console.log("<-- Exited ORDER_MENU.");`
            console.log("<-- Exited ORDER_MENU.");
        } // end of behavior for ORDER_MENU
        
        // ORDER_MENU behavior
        // uml: exit / { document.querySelector('g[data-id=ORDER_MENU]')?.classList.remove('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=ORDER_MENU]')?.classList.remove('active');`
            document.querySelector('g[data-id=ORDER_MENU]')?.classList.remove('active');
        } // end of behavior for ORDER_MENU
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ROOT_exit;
        this.#currentEventHandlers[LightSm.EventId.EV3] = null;  // no ancestor listens to this event
    }
    
    #ORDER_MENU_ev3()
    {
        // No ancestor state handles `ev3` event.
        
        // ORDER_MENU behavior
        // uml: EV3 TransitionTo(WAITING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#ROOT_exit);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `WAITING`.
            this.#WAITING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = LightSm.StateId.WAITING;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ORDER_MENU
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state BEVERAGE
    ////////////////////////////////////////////////////////////////////////////////
    
    #BEVERAGE_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#BEVERAGE_exit;
        this.#currentEventHandlers[LightSm.EventId.EV2] = this.#BEVERAGE_ev2;
        
        // BEVERAGE behavior
        // uml: enter / { document.querySelector('g[data-id=BEVERAGE]')?.classList.add('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=BEVERAGE]')?.classList.add('active');`
            document.querySelector('g[data-id=BEVERAGE]')?.classList.add('active');
        } // end of behavior for BEVERAGE
        
        // BEVERAGE behavior
        // uml: enter / { console.log("--> Entered BEVERAGE."); }
        {
            // Step 1: execute action `console.log("--> Entered BEVERAGE.");`
            console.log("--> Entered BEVERAGE.");
        } // end of behavior for BEVERAGE
        
        // BEVERAGE behavior
        // uml: enter / { $gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.BEVERAGE;) }
        {
            // Step 1: execute action `$gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.BEVERAGE;)`
            this.vars.ORDER_MENU_history = LightSm.ORDER_MENU_HistoryId.BEVERAGE;
        } // end of behavior for BEVERAGE
    }
    
    #BEVERAGE_exit()
    {
        // BEVERAGE behavior
        // uml: exit / { console.log("<-- Exited BEVERAGE."); }
        {
            // Step 1: execute action `console.log("<-- Exited BEVERAGE.");`
            console.log("<-- Exited BEVERAGE.");
        } // end of behavior for BEVERAGE
        
        // BEVERAGE behavior
        // uml: exit / { document.querySelector('g[data-id=BEVERAGE]')?.classList.remove('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=BEVERAGE]')?.classList.remove('active');`
            document.querySelector('g[data-id=BEVERAGE]')?.classList.remove('active');
        } // end of behavior for BEVERAGE
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ORDER_MENU_exit;
        this.#currentEventHandlers[LightSm.EventId.EV2] = null;  // no ancestor listens to this event
    }
    
    #BEVERAGE_ev2()
    {
        // No ancestor state handles `ev2` event.
        
        // BEVERAGE behavior
        // uml: EV2 TransitionTo(FOOD)
        {
            // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#ORDER_MENU_exit);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `FOOD`.
            this.#FOOD_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#FOOD_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for BEVERAGE
    }
    
    #BEVERAGE_InitialState_transition()
    {
        // BEVERAGE.<InitialState> behavior
        // uml: TransitionTo(WATER)
        {
            // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `WATER`.
            this.#WATER_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = LightSm.StateId.WATER;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for BEVERAGE.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state COFFEE
    ////////////////////////////////////////////////////////////////////////////////
    
    #COFFEE_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#COFFEE_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = this.#COFFEE_ev1;
        
        // COFFEE behavior
        // uml: enter / { document.querySelector('g[data-id=COFFEE]')?.classList.add('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=COFFEE]')?.classList.add('active');`
            document.querySelector('g[data-id=COFFEE]')?.classList.add('active');
        } // end of behavior for COFFEE
        
        // COFFEE behavior
        // uml: enter / { console.log("--> Entered COFFEE."); }
        {
            // Step 1: execute action `console.log("--> Entered COFFEE.");`
            console.log("--> Entered COFFEE.");
        } // end of behavior for COFFEE
        
        // COFFEE behavior
        // uml: enter / { do_x(); }
        {
            // Step 1: execute action `do_x();`
            do_x();
        } // end of behavior for COFFEE
        
        // COFFEE behavior
        // uml: enter / { $gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.COFFEE;) }
        {
            // Step 1: execute action `$gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.COFFEE;)`
            this.vars.ORDER_MENU_history = LightSm.ORDER_MENU_HistoryId.COFFEE;
        } // end of behavior for COFFEE
    }
    
    #COFFEE_exit()
    {
        // COFFEE behavior
        // uml: exit / { console.log("<-- Exited COFFEE."); }
        {
            // Step 1: execute action `console.log("<-- Exited COFFEE.");`
            console.log("<-- Exited COFFEE.");
        } // end of behavior for COFFEE
        
        // COFFEE behavior
        // uml: exit / { document.querySelector('g[data-id=COFFEE]')?.classList.remove('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=COFFEE]')?.classList.remove('active');`
            document.querySelector('g[data-id=COFFEE]')?.classList.remove('active');
        } // end of behavior for COFFEE
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#BEVERAGE_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = null;  // no ancestor listens to this event
    }
    
    #COFFEE_ev1()
    {
        // No ancestor state handles `ev1` event.
        
        // COFFEE behavior
        // uml: EV1 TransitionTo(TEA)
        {
            // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
            this.#COFFEE_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `TEA`.
            this.#TEA_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = LightSm.StateId.TEA;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for COFFEE
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TEA
    ////////////////////////////////////////////////////////////////////////////////
    
    #TEA_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#TEA_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = this.#TEA_ev1;
        this.#currentEventHandlers[LightSm.EventId.EV2] = this.#TEA_ev2;
        
        // TEA behavior
        // uml: enter / { document.querySelector('g[data-id=TEA]')?.classList.add('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=TEA]')?.classList.add('active');`
            document.querySelector('g[data-id=TEA]')?.classList.add('active');
        } // end of behavior for TEA
        
        // TEA behavior
        // uml: enter / { console.log("--> Entered TEA."); }
        {
            // Step 1: execute action `console.log("--> Entered TEA.");`
            console.log("--> Entered TEA.");
        } // end of behavior for TEA
        
        // TEA behavior
        // uml: enter / { $gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.TEA;) }
        {
            // Step 1: execute action `$gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.TEA;)`
            this.vars.ORDER_MENU_history = LightSm.ORDER_MENU_HistoryId.TEA;
        } // end of behavior for TEA
    }
    
    #TEA_exit()
    {
        // TEA behavior
        // uml: exit / { console.log("<-- Exited TEA."); }
        {
            // Step 1: execute action `console.log("<-- Exited TEA.");`
            console.log("<-- Exited TEA.");
        } // end of behavior for TEA
        
        // TEA behavior
        // uml: exit / { document.querySelector('g[data-id=TEA]')?.classList.remove('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=TEA]')?.classList.remove('active');`
            document.querySelector('g[data-id=TEA]')?.classList.remove('active');
        } // end of behavior for TEA
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#BEVERAGE_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = null;  // no ancestor listens to this event
        this.#currentEventHandlers[LightSm.EventId.EV2] = this.#BEVERAGE_ev2;  // the next ancestor that handles this event is BEVERAGE
    }
    
    #TEA_ev1()
    {
        // No ancestor state handles `ev1` event.
        
        // TEA behavior
        // uml: EV1 TransitionTo(COFFEE)
        {
            // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
            this.#TEA_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `COFFEE`.
            this.#COFFEE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = LightSm.StateId.COFFEE;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for TEA
    }
    
    #TEA_ev2()
    {
        // Setup handler for next ancestor that listens to `ev2` event.
        this.#ancestorEventHandler = this.#BEVERAGE_ev2;
        
        // TEA behavior
        // uml: EV2 TransitionTo(BEVERAGE.<InitialState>)
        {
            // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
            this.#TEA_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `BEVERAGE.<InitialState>`.
            // BEVERAGE.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            this.#BEVERAGE_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEA
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WATER
    ////////////////////////////////////////////////////////////////////////////////
    
    #WATER_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#WATER_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = this.#WATER_ev1;
        
        // WATER behavior
        // uml: enter / { document.querySelector('g[data-id=WATER]')?.classList.add('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=WATER]')?.classList.add('active');`
            document.querySelector('g[data-id=WATER]')?.classList.add('active');
        } // end of behavior for WATER
        
        // WATER behavior
        // uml: enter / { console.log("--> Entered WATER."); }
        {
            // Step 1: execute action `console.log("--> Entered WATER.");`
            console.log("--> Entered WATER.");
        } // end of behavior for WATER
        
        // WATER behavior
        // uml: enter / { $gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.WATER;) }
        {
            // Step 1: execute action `$gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.WATER;)`
            this.vars.ORDER_MENU_history = LightSm.ORDER_MENU_HistoryId.WATER;
        } // end of behavior for WATER
    }
    
    #WATER_exit()
    {
        // WATER behavior
        // uml: exit / { console.log("<-- Exited WATER."); }
        {
            // Step 1: execute action `console.log("<-- Exited WATER.");`
            console.log("<-- Exited WATER.");
        } // end of behavior for WATER
        
        // WATER behavior
        // uml: exit / { document.querySelector('g[data-id=WATER]')?.classList.remove('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=WATER]')?.classList.remove('active');`
            document.querySelector('g[data-id=WATER]')?.classList.remove('active');
        } // end of behavior for WATER
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#BEVERAGE_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = null;  // no ancestor listens to this event
    }
    
    #WATER_ev1()
    {
        // No ancestor state handles `ev1` event.
        
        // WATER behavior
        // uml: EV1 TransitionTo(COFFEE)
        {
            // Step 1: Exit states until we reach `BEVERAGE` state (Least Common Ancestor for transition).
            this.#WATER_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `COFFEE`.
            this.#COFFEE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = LightSm.StateId.COFFEE;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for WATER
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state FOOD
    ////////////////////////////////////////////////////////////////////////////////
    
    #FOOD_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#FOOD_exit;
        this.#currentEventHandlers[LightSm.EventId.ESCAPE] = this.#FOOD_escape;
        this.#currentEventHandlers[LightSm.EventId.EV2] = this.#FOOD_ev2;
        
        // FOOD behavior
        // uml: enter / { document.querySelector('g[data-id=FOOD]')?.classList.add('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=FOOD]')?.classList.add('active');`
            document.querySelector('g[data-id=FOOD]')?.classList.add('active');
        } // end of behavior for FOOD
        
        // FOOD behavior
        // uml: enter / { console.log("--> Entered FOOD."); }
        {
            // Step 1: execute action `console.log("--> Entered FOOD.");`
            console.log("--> Entered FOOD.");
        } // end of behavior for FOOD
        
        // FOOD behavior
        // uml: enter / { $gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.FOOD;) }
        {
            // Step 1: execute action `$gil(this.vars.ORDER_MENU_history = ORDER_MENU_HistoryId.FOOD;)`
            this.vars.ORDER_MENU_history = LightSm.ORDER_MENU_HistoryId.FOOD;
        } // end of behavior for FOOD
    }
    
    #FOOD_exit()
    {
        // FOOD behavior
        // uml: exit / { console.log("<-- Exited FOOD."); }
        {
            // Step 1: execute action `console.log("<-- Exited FOOD.");`
            console.log("<-- Exited FOOD.");
        } // end of behavior for FOOD
        
        // FOOD behavior
        // uml: exit / { document.querySelector('g[data-id=FOOD]')?.classList.remove('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=FOOD]')?.classList.remove('active');`
            document.querySelector('g[data-id=FOOD]')?.classList.remove('active');
        } // end of behavior for FOOD
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ORDER_MENU_exit;
        this.#currentEventHandlers[LightSm.EventId.ESCAPE] = null;  // no ancestor listens to this event
        this.#currentEventHandlers[LightSm.EventId.EV2] = null;  // no ancestor listens to this event
    }
    
    #FOOD_escape()
    {
        // No ancestor state handles `escape` event.
        
        // FOOD behavior
        // uml: ESCAPE TransitionTo(ORDER_MENU.<ExitPoint>(1))
        {
            // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#ORDER_MENU_exit);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ORDER_MENU.<ExitPoint>(1)`.
            // ORDER_MENU.<ExitPoint>(1) is a pseudo state and cannot have an `enter` trigger.
            
            // ORDER_MENU.<ExitPoint>(1) behavior
            // uml: TransitionTo(WAITING)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#ORDER_MENU_exit();
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `WAITING`.
                this.#WAITING_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = LightSm.StateId.WAITING;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for ORDER_MENU.<ExitPoint>(1)
        } // end of behavior for FOOD
    }
    
    #FOOD_ev2()
    {
        // No ancestor state handles `ev2` event.
        
        // FOOD behavior
        // uml: EV2 TransitionTo(ORDER_MENU.<ChoicePoint>(bev_choice))
        {
            // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#ORDER_MENU_exit);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ORDER_MENU.<ChoicePoint>(bev_choice)`.
            // ORDER_MENU.<ChoicePoint>(bev_choice) is a pseudo state and cannot have an `enter` trigger.
            
            // ORDER_MENU.<ChoicePoint>(bev_choice) behavior
            // uml: [a > b] TransitionTo(TEA)
            if (a > b)
            {
                // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `TEA`.
                this.#BEVERAGE_enter();
                this.#TEA_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = LightSm.StateId.TEA;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for ORDER_MENU.<ChoicePoint>(bev_choice)
            
            // ORDER_MENU.<ChoicePoint>(bev_choice) behavior
            // uml: else TransitionTo(BEVERAGE)
            {
                // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `BEVERAGE`.
                this.#BEVERAGE_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#BEVERAGE_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for ORDER_MENU.<ChoicePoint>(bev_choice)
        } // end of behavior for FOOD
    }
    
    #FOOD_InitialState_transition()
    {
        // FOOD.<InitialState> behavior
        // uml: TransitionTo(JUNK)
        {
            // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `JUNK`.
            this.#JUNK_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = LightSm.StateId.JUNK;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for FOOD.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state JUNK
    ////////////////////////////////////////////////////////////////////////////////
    
    #JUNK_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#JUNK_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = this.#JUNK_ev1;
        
        // JUNK behavior
        // uml: enter / { document.querySelector('g[data-id=JUNK]')?.classList.add('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=JUNK]')?.classList.add('active');`
            document.querySelector('g[data-id=JUNK]')?.classList.add('active');
        } // end of behavior for JUNK
        
        // JUNK behavior
        // uml: enter / { console.log("--> Entered JUNK."); }
        {
            // Step 1: execute action `console.log("--> Entered JUNK.");`
            console.log("--> Entered JUNK.");
        } // end of behavior for JUNK
    }
    
    #JUNK_exit()
    {
        // JUNK behavior
        // uml: exit / { console.log("<-- Exited JUNK."); }
        {
            // Step 1: execute action `console.log("<-- Exited JUNK.");`
            console.log("<-- Exited JUNK.");
        } // end of behavior for JUNK
        
        // JUNK behavior
        // uml: exit / { document.querySelector('g[data-id=JUNK]')?.classList.remove('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=JUNK]')?.classList.remove('active');`
            document.querySelector('g[data-id=JUNK]')?.classList.remove('active');
        } // end of behavior for JUNK
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#FOOD_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = null;  // no ancestor listens to this event
    }
    
    #JUNK_ev1()
    {
        // No ancestor state handles `ev1` event.
        
        // JUNK behavior
        // uml: EV1 TransitionTo(POTATO)
        {
            // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition).
            this.#JUNK_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `POTATO`.
            this.#POTATO_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = LightSm.StateId.POTATO;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for JUNK
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state POTATO
    ////////////////////////////////////////////////////////////////////////////////
    
    #POTATO_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#POTATO_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = this.#POTATO_ev1;
        
        // POTATO behavior
        // uml: enter / { document.querySelector('g[data-id=POTATO]')?.classList.add('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=POTATO]')?.classList.add('active');`
            document.querySelector('g[data-id=POTATO]')?.classList.add('active');
        } // end of behavior for POTATO
        
        // POTATO behavior
        // uml: enter / { console.log("--> Entered POTATO."); }
        {
            // Step 1: execute action `console.log("--> Entered POTATO.");`
            console.log("--> Entered POTATO.");
        } // end of behavior for POTATO
    }
    
    #POTATO_exit()
    {
        // POTATO behavior
        // uml: exit / { console.log("<-- Exited POTATO."); }
        {
            // Step 1: execute action `console.log("<-- Exited POTATO.");`
            console.log("<-- Exited POTATO.");
        } // end of behavior for POTATO
        
        // POTATO behavior
        // uml: exit / { document.querySelector('g[data-id=POTATO]')?.classList.remove('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=POTATO]')?.classList.remove('active');`
            document.querySelector('g[data-id=POTATO]')?.classList.remove('active');
        } // end of behavior for POTATO
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#FOOD_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = null;  // no ancestor listens to this event
    }
    
    #POTATO_ev1()
    {
        // No ancestor state handles `ev1` event.
        
        // POTATO behavior
        // uml: EV1 TransitionTo(SUSHI)
        {
            // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition).
            this.#POTATO_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SUSHI`.
            this.#SUSHI_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = LightSm.StateId.SUSHI;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for POTATO
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SUSHI
    ////////////////////////////////////////////////////////////////////////////////
    
    #SUSHI_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#SUSHI_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = this.#SUSHI_ev1;
        
        // SUSHI behavior
        // uml: enter / { document.querySelector('g[data-id=SUSHI]')?.classList.add('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=SUSHI]')?.classList.add('active');`
            document.querySelector('g[data-id=SUSHI]')?.classList.add('active');
        } // end of behavior for SUSHI
        
        // SUSHI behavior
        // uml: enter / { console.log("--> Entered SUSHI."); }
        {
            // Step 1: execute action `console.log("--> Entered SUSHI.");`
            console.log("--> Entered SUSHI.");
        } // end of behavior for SUSHI
    }
    
    #SUSHI_exit()
    {
        // SUSHI behavior
        // uml: exit / { console.log("<-- Exited SUSHI."); }
        {
            // Step 1: execute action `console.log("<-- Exited SUSHI.");`
            console.log("<-- Exited SUSHI.");
        } // end of behavior for SUSHI
        
        // SUSHI behavior
        // uml: exit / { document.querySelector('g[data-id=SUSHI]')?.classList.remove('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=SUSHI]')?.classList.remove('active');`
            document.querySelector('g[data-id=SUSHI]')?.classList.remove('active');
        } // end of behavior for SUSHI
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#FOOD_exit;
        this.#currentEventHandlers[LightSm.EventId.EV1] = null;  // no ancestor listens to this event
    }
    
    #SUSHI_ev1()
    {
        // No ancestor state handles `ev1` event.
        
        // SUSHI behavior
        // uml: EV1 TransitionTo(JUNK)
        {
            // Step 1: Exit states until we reach `FOOD` state (Least Common Ancestor for transition).
            this.#SUSHI_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `JUNK`.
            this.#JUNK_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = LightSm.StateId.JUNK;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for SUSHI
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WAITING
    ////////////////////////////////////////////////////////////////////////////////
    
    #WAITING_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#WAITING_exit;
        this.#currentEventHandlers[LightSm.EventId.EV3] = this.#WAITING_ev3;
        
        // WAITING behavior
        // uml: enter / { document.querySelector('g[data-id=WAITING]')?.classList.add('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=WAITING]')?.classList.add('active');`
            document.querySelector('g[data-id=WAITING]')?.classList.add('active');
        } // end of behavior for WAITING
        
        // WAITING behavior
        // uml: enter / { console.log("--> Entered WAITING."); }
        {
            // Step 1: execute action `console.log("--> Entered WAITING.");`
            console.log("--> Entered WAITING.");
        } // end of behavior for WAITING
    }
    
    #WAITING_exit()
    {
        // WAITING behavior
        // uml: exit / { console.log("<-- Exited WAITING."); }
        {
            // Step 1: execute action `console.log("<-- Exited WAITING.");`
            console.log("<-- Exited WAITING.");
        } // end of behavior for WAITING
        
        // WAITING behavior
        // uml: exit / { document.querySelector('g[data-id=WAITING]')?.classList.remove('active'); }
        {
            // Step 1: execute action `document.querySelector('g[data-id=WAITING]')?.classList.remove('active');`
            document.querySelector('g[data-id=WAITING]')?.classList.remove('active');
        } // end of behavior for WAITING
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ROOT_exit;
        this.#currentEventHandlers[LightSm.EventId.EV3] = null;  // no ancestor listens to this event
    }
    
    #WAITING_ev3()
    {
        // No ancestor state handles `ev3` event.
        
        // WAITING behavior
        // uml: EV3 TransitionTo(ORDER_MENU.<EntryPoint>(to_history))
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#WAITING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ORDER_MENU.<EntryPoint>(to_history)`.
            this.#ORDER_MENU_enter();
            // ORDER_MENU.<EntryPoint>(to_history) is a pseudo state and cannot have an `enter` trigger.
            
            // ORDER_MENU.<EntryPoint>(to_history) behavior
            // uml: TransitionTo(ORDER_MENU.<History>)
            {
                // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ORDER_MENU.<History>`.
                // ORDER_MENU.<History> is a pseudo state and cannot have an `enter` trigger.
                
                // ORDER_MENU.<History> behavior
                // uml: [$gil(this.vars.ORDER_MENU_history == ORDER_MENU_HistoryId.FOOD)] TransitionTo(FOOD)
                if (this.vars.ORDER_MENU_history == LightSm.ORDER_MENU_HistoryId.FOOD)
                {
                    // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `FOOD`.
                    this.#FOOD_enter();
                    
                    // Finish transition by calling pseudo state transition function.
                    this.#FOOD_InitialState_transition();
                    return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
                } // end of behavior for ORDER_MENU.<History>
                
                // ORDER_MENU.<History> behavior
                // uml: [$gil(this.vars.ORDER_MENU_history == ORDER_MENU_HistoryId.WATER)] TransitionTo(WATER)
                if (this.vars.ORDER_MENU_history == LightSm.ORDER_MENU_HistoryId.WATER)
                {
                    // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `WATER`.
                    this.#BEVERAGE_enter();
                    this.#WATER_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    this.stateId = LightSm.StateId.WATER;
                    // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                    return;
                } // end of behavior for ORDER_MENU.<History>
                
                // ORDER_MENU.<History> behavior
                // uml: [$gil(this.vars.ORDER_MENU_history == ORDER_MENU_HistoryId.COFFEE)] TransitionTo(COFFEE)
                if (this.vars.ORDER_MENU_history == LightSm.ORDER_MENU_HistoryId.COFFEE)
                {
                    // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `COFFEE`.
                    this.#BEVERAGE_enter();
                    this.#COFFEE_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    this.stateId = LightSm.StateId.COFFEE;
                    // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                    return;
                } // end of behavior for ORDER_MENU.<History>
                
                // ORDER_MENU.<History> behavior
                // uml: [$gil(this.vars.ORDER_MENU_history == ORDER_MENU_HistoryId.TEA)] TransitionTo(TEA)
                if (this.vars.ORDER_MENU_history == LightSm.ORDER_MENU_HistoryId.TEA)
                {
                    // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `TEA`.
                    this.#BEVERAGE_enter();
                    this.#TEA_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    this.stateId = LightSm.StateId.TEA;
                    // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                    return;
                } // end of behavior for ORDER_MENU.<History>
                
                // ORDER_MENU.<History> behavior
                // uml: else TransitionTo(BEVERAGE)
                {
                    // Step 1: Exit states until we reach `ORDER_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `BEVERAGE`.
                    this.#BEVERAGE_enter();
                    
                    // Finish transition by calling pseudo state transition function.
                    this.#BEVERAGE_InitialState_transition();
                    return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
                } // end of behavior for ORDER_MENU.<History>
            } // end of behavior for ORDER_MENU.<EntryPoint>(to_history)
        } // end of behavior for WAITING
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case LightSm.StateId.ROOT: return "ROOT";
            case LightSm.StateId.ORDER_MENU: return "ORDER_MENU";
            case LightSm.StateId.BEVERAGE: return "BEVERAGE";
            case LightSm.StateId.COFFEE: return "COFFEE";
            case LightSm.StateId.TEA: return "TEA";
            case LightSm.StateId.WATER: return "WATER";
            case LightSm.StateId.FOOD: return "FOOD";
            case LightSm.StateId.JUNK: return "JUNK";
            case LightSm.StateId.POTATO: return "POTATO";
            case LightSm.StateId.SUSHI: return "SUSHI";
            case LightSm.StateId.WAITING: return "WAITING";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case LightSm.EventId.ESCAPE: return "ESCAPE";
            case LightSm.EventId.EV1: return "EV1";
            case LightSm.EventId.EV2: return "EV2";
            case LightSm.EventId.EV3: return "EV3";
            default: return "?";
        }
    }
}
