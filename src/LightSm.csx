#!/usr/bin/env dotnet-script
// This is a c# script file

#r "nuget: StateSmith, 0.9.13-alpha-tracking-expander-2" // this line specifies which version of StateSmith to use and download from c# nuget web service.

using StateSmith.Input.Expansions;
using StateSmith.Output.UserConfig;
using StateSmith.Runner;
using StateSmith.SmGraph;  // Note using! This is required to access StateMachine and NamedVertex classes...

public StringBuilder imports = new();
public StringBuilder mocks = new();
public StringBuilder tests = new();


var trackingExpander = new TrackingExpander();
SmRunner runner = new(diagramPath: "LightSm.drawio.svg", new LightSmRenderConfig(), transpilerId: TranspilerId.JavaScript);
runner.GetExperimentalAccess().DiServiceProvider.AddSingletonT<IExpander>(trackingExpander); // must be done before AddPipelineStep();
AddPipelineStep();
runner.Run();

mocks.Append("// Mock the functions used by the state machine.\n");
mocks.Append("// We recommend mocking rather than importing your actual functions,\n");
mocks.Append("// to keep these tests purely about testing the state machine itself.\n");
mocks.Append("// (Your function implementations should also be tested, but in separate tests.)\n");
mocks.Append("\n");

foreach (var funcAttempt in trackingExpander.AttemptedFunctionExpansions)
{
    mocks.Append($"globalThis.{funcAttempt} = jest.fn();\n");
}

Console.Write(imports.ToString());
Console.WriteLine();
Console.Write(mocks.ToString());
Console.WriteLine();
Console.Write(tests.ToString());


void AddPipelineStep()
{
    // This method adds your custom step into the StateSmith transformation pipeline.
    // Some more info here: https://github.com/StateSmith/StateSmith/wiki/How-StateSmith-Works
    runner.SmTransformer.InsertBeforeFirstMatch(StandardSmTransformer.TransformationId.Standard_Validation1, 
                                                new TransformationStep(id: "my custom step blah", PrintSmInfo));
}

// This shows roughly how to inspect a state machine.
// This same idea could be used to generate test scaffolding code or to generate documentation.
void PrintSmInfo(StateMachine sm)
{
    BehaviorDescriber describer = new(singleLineFormat: true);

    InitialState rootInitialState = sm.ChildType<InitialState>();

    // Imports    
    imports.Append("// This is a sample test file for the LightSm state machine.\n");
    imports.Append("// Generated by StateSmith.\n");
    imports.Append("// Feel free to make a copy and start adding your own tests.\n");
    imports.Append("\n");

    imports.Append("// This sample uses npm and jest to run tests. \n");
    imports.Append("//\n");
    imports.Append("// To setup tests:\n");
    imports.Append("// - install npm if you don't already have it (https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)\n");
    imports.Append("// - Install the jest dev dependency: `npm install --save-dev jest`\n");
    imports.Append("// - edit your package.json file, see package.sample.json for an example\n");
    imports.Append("//   (Jest needs some light setup to work with ES6 modules for 'import' and 'export')\n");
    imports.Append("//\n");
    imports.Append("// To run, type `npm test` in the terminal\n");
    imports.Append("\n");

    imports.Append($"import {{jest}} from '@jest/globals';\n");
    imports.Append($"import {{ {sm.Name} }} from './{sm.Name}.js';\n");

    // beforeEach
    tests.Append($"beforeEach(() => {{\n");
    tests.Append($"    jest.clearAllMocks();\n" );
    tests.Append($"}});\n");
    tests.Append("\n");

    tests.Append("// Use 'stateId' to access the current state of the state machine, eg.\n");
    tests.Append("// expect(sm.stateId).toBe(LightSm.StateId.OFF);\n");
    tests.Append("//\n");
    tests.Append("// Use 'vars' to access the variables of the state machine, eg.\n");
    tests.Append("// expect(sm.vars.myVar).toBe(42);\n");
    tests.Append("//\n");
    tests.Append("// Use 'dispatchEvent' to send events to the state machine, eg.\n");
    tests.Append("// sm.dispatchEvent(LightSm.EventId.INCREASE);\n");
    tests.Append("//\n");
    tests.Append("// Use mock functions to check if the functions are called, eg.\n");
    tests.Append("// expect(globalThis.println.mock.calls).toHaveLength(1);\n");
    tests.Append("// See https://jestjs.io/ for more information on Jest.\n");
    tests.Append("\n");

    // TODO this will not work in every case, but it's a start
    NamedVertex firstState = (NamedVertex)rootInitialState.TransitionBehaviors().Single().TransitionTarget;
    tests.Append($"test('starts in the {firstState.Name} state', () => {{\n");
    tests.Append($"    const sm = new {sm.Name}();\n");
    tests.Append($"    sm.start();\n");
    tests.Append($"    expect(sm.stateId).toBe({sm.Name}.StateId.{firstState.Name});\n" );
    tests.Append($"}});\n");
}


public class LightSmRenderConfig : IRenderConfigJavaScript
{
    bool IRenderConfigJavaScript.UseExportOnClass => true;

    string IRenderConfig.AutoExpandedVars => """
        count: 0 // variable for state machine
        """;

    
    // This nested class creates expansions. It can have any name.
    public class MyExpansions : UserExpansionScriptBase
    {
    }
}
